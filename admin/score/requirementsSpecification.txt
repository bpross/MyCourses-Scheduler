Requirements Specification

	This section is designed to provide an overview of S.C.O.R.E. Scheduling based upon the requirements above. Within this section, one will understand the power behind the technology used for this system: the web server technology and the algorithm used to schedule the classes. To begin, the web server for the S.C.O.R.E. Scheduling system is Django, strictly because of its ability to ease the creation of database-driven websites. It provides an abstracted framework for dynamic websites that is easy to learn and easy to integrate. The available components also will help us throughout this design process, such as the clever template system interfacing with the user interface. Django is written in Python, which is the language of choice for this project, as well as the language of our algorithm.
	     When deciding upon an algorithm, we needed to decide whether to go with a constraint-based solver, or to design an algorithm in-house to fulfill out needs. Because the scheduling problem is an NP-Hard problem, by using a constraint-based solver, it would ease the programming end of the algorithm team; however, learning to use a constraint-based solver would require more time to learn. On the other side to this decision, designing an algorithm in-house would provide full control of the algorithm in how we decide to integrate it with the web server framework.
Looking at figure three, the class diagram depicts an overall outlook of our in-house algorithm, of which will be the heart and engine of our Scheduling system. This class diagram shows the relationship between the configuration Python file with the different database attributes, such as professor, course, room, schedule, and course class. The configuration class is the primary driver that weaves all the user groups and database attributes together to function as a single entity.  

 [INSERT classDiagram.jpg HERE]

Figure 3: Class Diagram of Algorithm

Once one understands the algorithm above, then it can then be applied to the multiple use cases that it will be serving for. The interaction diagrams below contain every interaction of each user: student, lecturer, program manager, and program administrator. Each diagram details a pictorial representation of the user’s interaction with the system, such as the HTML website, the Django engine, the database that’s handled, or the algorithm itself.  In all these diagrams, the HTML portal, or front-end website, is an input/output object wherein users will input items and receive output from Django. From behind the front-end website, Django serves as a control object that handles all aspects of user, algorithm, and database interactions. The database itself is an entity that stores information from user input processed by Django, and it also provides output to the user. Lastly, the algorithm is a control entity that manipulates the database courses, but all functionality of the algorithm remains hidden from the entire system. 

[INSERT studentID.jpg HERE]

Figure 3.1: Student interaction diagram

1.     The student will login with their ID and password on the portal. Django will read the ID and password and match it with the database. 
2.     Once the database confirms user, the database will return the correct UI for the student.
3.     The student will want to get the schedule of classes to sign up for and “makes a request” to Django and the database to display the available courses. By “making a request”, this is done invisible to the user and the user will simply click on the courses tab. It will open automatically for the user. 
4.     The student can now select courses and store them into their profile on the database. 

[INSERT programAdminID.jpg HERE]

 Figure 3.2: Program Admin enters courses interaction diagram

1.	The program administrator will login with their ID and password on the portal. Django will read the ID and password and match it with the database. 
2.	Once the database confirms user, the database will return the correct UI for the program administrator.
3.	The program administrator will want to know the status of the schedule, to see if it is finished or not, and will make a request to both Django and the database to find out the status. 
4.	The database will return the status. 
5.	The program administrator will begin filling out course information through a courseInfo object that will contain various data about a given course.
6.	When the program administrator feels done, they can choose to submit the course and lock the course in the database. 

[INSERT programAdminID2.jpg HERE]

 Figure 3.3: Program Administrator runs algorithm interaction diagram

1.	The program administrator will login with their ID and password on the portal. Django will read the ID and password and match it with the database. 
2.	Once the database confirms user, the database will return the correct UI for the program administrator.
3.	The program administrator will want to know the status of the schedule, to see if it is finished or not, and will make a request to both Django and the database to find out the status. 
4.	The database will return the status to see if the program manager has completed the schedule. 
5.	If the schedule is complete, the program administrator will run the algorithm that will be passed through Django and straight into the algorithm engine.
6.	When the engine has completed, it will return a message that it is complete to the HTML website. 
7.	Once the program administrator reviews the schedule, the program administrator can submit and lock the schedule and provide it to students

[INSERT lecturerID.jpg HERE]

 Figure 4: Lecturer interaction diagram

1.	The lecturer will login with their ID and password on the portal. Django will read the ID and password, and match it with the database. 
2.	Once the database confirms user, the database will return the correct UI for the lecturer.
3.	The lecturer will want to find out the constraint form has been completed. Upon logging in, Django will send a message on the status of his constraint form, based upon a status in the database.
4.	The lecturer will fill out the constraint form and store it in the database.
5.	Upon storing it in the database, the lecture status will be updated and confirmed. 
6.	The lecturer can now formally submit his constraints form to the database. 

[INSERT programManagerID.jpg HERE]
 
 Figure 5: Program Manager interaction diagram

1.	The program manager will login with their ID and password on the portal. Django will read the ID and password and match it with the database. 
2.	Once the database confirms user, the database will return the correct UI for the program manager.
3.	Upon logging in, Django will automatically send a request to find out the department status of the courses. 
4.	If the status is not yet been completed, it will send a message to the program manager.
5.	The program manager can modify the courses that was made available from the program administrator and placed in the database. 
6.	Upon modifying the courses and the course info, the program manager can confirm and submit the finalized course. 

